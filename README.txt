ProcessCommand Function:
  -> The function interprets and executes user commands. It begins by tokenizing the input command into individual words or tokens, which are then analyzed to determine the nature of the command. This function handles various scenarios, including empty commands, exit commands, and conditional execution based on the outcome of the previous command. It also manages wildcard expansion, dynamically adapting the command tokens to match filenames and other patterns in the file system. The function intelligently identifies and separates piping and redirection elements within the command. For commands involving pipes, it delegates the execution to createAndExecutePipe or createAndExecutePipeWithRedirection, depending on whether output redirection is also involved. For commands without pipes, it handles potential redirections and executes either built-in commands (like `cd`, `pwd`, `which`) or external commands. The function also carefully manages memory, particularly for dynamically allocated tokens, ensuring robust and leak-free execution. In essence, processCommand acts as the command interpreter and executor, translating user input into actions and delegating complex tasks to specialized sub-functions within the shell program.

ExpandWildcards Function:
  -> This function plays a crucial role in handling wildcard characters, such as `*`, in command inputs. It scans the command tokens and, upon encountering a token containing a wildcard, utilizes the `glob` function to match this pattern with existing file paths. For each match found, the function dynamically allocates memory to store these file paths, effectively replacing the wildcard token with a list of actual filenames or directories. Tokens without wildcards remain unaffected. This mechanism allows your shell to interpret and expand wildcard patterns, enabling users to execute commands on multiple files or directories simultaneously.

CreateAndExecutePipe Function:
  -> This function allows the output of one command to be used as the input for another. This function sets up a pipeline between two commands, defined by the `leftCommand` and `rightCommand` arrays. It creates a pipe using the `pipe()` system call, then forks two child processes. In the first child process, it redirects the standard output to the write end of the pipe, and then executes the leftCommand using execv(). In the second child process, it redirects the standard input to the read end of the pipe and executes the rightCommand. The parent process waits for both children to finish, ensuring proper command execution and data transfer between the two commands through the pipe. This function elegantly captures the essence of Unix pipelines, enabling complex command sequences.

CreateAndExecutePipeWithRedirection:
  -> This function combines the capabilities of piping and output redirection. This function is designed to execute two commands, specified by leftCommand and rightCommand, with the output of the rightCommand being redirected to a file specified by outputFile. The process involves creating a pipe and forking two child processes. In the first child process, it handles the leftCommand, redirecting its output to the write end of the pipe. The second child process deals with the rightCommand, taking its input from the read end of the pipe and redirecting its output to the specified file. This is achieved using file descriptors and the `dup2()` system call. After setting up these redirections, each child process executes its respective command using execv(). The parent process waits for both child processes to complete. This function allows complex command execution where the output of one command can be processed by another and then saved directly to a file.
